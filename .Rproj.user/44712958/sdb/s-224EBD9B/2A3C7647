{
    "contents" : "#' DGSA main function\n#'\n#' @title DGSA main function\n#'\n#' @param clusters   - from some method like kmedoids\n#' @param parameters - a data frame with parameters stacked in columns and designs in rows.\n#' @param .normalize - Whether to normalize with .alpha boostrapped or not.\n#' @param .nBoot     - The number of bootstrapped samples for normalization computation.\n#' @details This code implements the original DGSA code by Celine Scheidt.\n#' @param .interactions - boolean, specifying whether to compute interactions (default = FALSE)\n#'\n#' @author Ogy Grujic (ogyg@stanford.edu)\n#'\n#' @export\n#'\n#'\ndgsa <- function(.clusters, .X, .normalize = TRUE, .nBoot = 100,\n                 .interactions = FALSE, .nBins = 3,\n                 .alpha = 0.95, .parallel = FALSE, .progress = TRUE){\n\n  .l1 <- function(.PARAMETERS, .CLUSTERS){\n\n    .clusterCategories <- unique(.CLUSTERS)\n    .clustCount <- apply(as.matrix(unique(.CLUSTERS)), 1, function(x) sum(.CLUSTERS==x))\n    .N <- nrow(.PARAMETERS)\n\n    .priors  <- apply(.PARAMETERS, 2, function(x) quantile(x, seq(0,1,0.01)))\n    .l1 <- matrix(NA, nrow = length(.clusterCategories), ncol=ncol(.PARAMETERS))\n\n    # L1 on each cluster:\n    for(i in 1:length(.clusterCategories)){\n      .l1[i,] <- colSums(abs(.priors - apply(.PARAMETERS[.CLUSTERS==.clusterCategories[i],], 2,\n                                             function(x) quantile(x, seq(0,1,0.01)))))\n    }\n\n    if(.normalize){\n\n      .bootMatrix <- array(NA, c(length(.clusterCategories), ncol(.PARAMETERS), .nBoot));\n\n      for(j in 1:.nBoot){\n        for(i in 1:length(.clusterCategories)){\n          .bootMatrix[i, ,j] <- colSums(\n            abs(.priors - apply(.PARAMETERS[sample(.N,.clustCount[i], replace=FALSE),], 2,\n                                function(x) quantile(x, seq(0, 1, 0.01))\n            )\n            )\n          )\n        }\n      }\n\n      .bootMatrix <- apply(.bootMatrix, c(1,2), function(x) quantile(x, .alpha))\n\n      return(round(.l1, 9) / round(.bootMatrix, 9))\n\n    } else {\n\n      return(round(.l1, 9))\n\n    }\n\n  }\n\n  .sensitivityMatrix <- array(NaN, c(length(unique(.clusters)), ncol(.X), ncol(.X)))\n\n  # Compute Matrix Elements:\n  if(.progress)  print('Computing main effects...')\n\n  .diagonal    <- .l1(.X, .clusters)\n\n  if(.interactions){\n\n    if(.progress) print('Computing Interactions...')\n\n    for(param in 1:ncol(.X)){\n\n      if(.progress) print(paste('    Computing interactions conditioned on ', colnames(.X)[param], \"...\", sep = \"\"))\n\n       for(clust in 1:length(unique(.clusters))){\n\n         .currentX <- .X[.clusters == clust, ]\n\n         .brks = quantile(.currentX[, param], seq(0, 1, 1/.nBins))\n\n         if(length(unique(round(.brks,8))) > 1 && anyDuplicated(.brks) == 0){\n\n           .binning  <- cut(.currentX[,param],\n                            breaks = .brks,\n                            include.lowest = TRUE, right = TRUE, labels = FALSE)\n\n           .sensitivityMatrix[clust, param, ] <- apply(.l1(.currentX, .binning), 2, mean)\n\n         } else {\n\n           if(.progress) print(paste('        Computation failed due to inability to split  ',\n                               colnames(.X)[param], \"  into \", .nBins, ' bins.', sep = \"\"))\n\n         }\n       }\n    }\n\n  }\n\n  # Replace the diagonal:\n  for(i in 1:dim(.sensitivityMatrix)[1]){\n    diag(.sensitivityMatrix[i, , ]) <- .diagonal[i,]\n  }\n\n  ret <- list(sensitivityMatrix = .sensitivityMatrix,\n              parameters = colnames(.X))\n\n  class(ret) <- 'DGSAstructure'\n\n  return(ret)\n\n}\n\n\n#' @title DGSA visualization routine\n#'\n#' @param .dgsa       - a \"DGSAstructure\" class object as produced by \\code{dgsa} function\n#' @param .hypothesis - whether to mark sensitive or not sensitive (star = sensitive)\n#' @param .method     - method for corrPlot (circle is default);\n#' @param  ...        - whatever else setting you want to pass to corrPlot (see help(corrPlot))\n#'\n#' @details  It simply computes the mean of the sensitivity matrix and passess it to\n#'           corrPlot to visualize both interactions and main effects.\n#'\n#' @author  Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\n#'\nplotMatrixDGSA <- function(.dgsa, .hypothesis = TRUE, .method='circle', ...){\n\n  if(class(.dgsa) != 'DGSAstructure') stop('Passed object is not of class DGSAstructure. Exiting!')\n\n  .corrMat <- apply(.dgsa$sensitivityMatrix, c(2,3), mean)\n  .corrMat[is.nan(.corrMat)] = 0\n  colnames(.corrMat) = rownames(.corrMat) <- .dgsa$parameters\n\n  if(.hypothesis){\n    .significance <- 0.99 - apply(.dgsa$sensitivityMatrix, c(2,3), min)\n    .significance[is.nan(.significance)] = 0\n  } else {\n    .significance <- NULL\n  }\n\n  corrplot(.corrMat, method=.method, is.corr=FALSE, p.mat = .significance, sig.level = 0, ...)\n\n}\n\n#' @title creates ggplot based pareto plots for dgsa\n#'\n#' @param .dgsa        -  a \"DGSAstructure\" class object as produced by \\code{dgsa} function\n#' @param .clusters    - whether to plot cluster specific L1 norms or not\n#' @param .interaction - specify which interaction to plot i.e. \"a|b\", both \"a\" and \"b\"\n#'                       have to be parameters names already present in the dataset.\n#' @param .ggReturn    - whether or not to return a ggplot structure (for adjustments)\n#'\n#' @details This code uses ggplot for plotting it will throw out a very basic plot\n#'\n#' @author  Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\n#'\nplotParetoDGSA <- function(.dgsa, .clusters = FALSE, .interaction = NULL, .hypothesis = TRUE, .ggReturn = FALSE){\n\n  if(class(.dgsa) != 'DGSAstructure') stop('Passed object is not of class DGSAstructure. Exiting!')\n\n  if(!is.null(.interaction)){\n    .paramIndex <- which(.dgsa$parameters == .interaction)\n    if(length(.paramIndex) == 0) stop('Parameter provided in \".interaction\" not found. Exiting!')\n    .ggDATA <- t(.dgsa$sensitivityMatrix[,.paramIndex,])\n    .plotTitle <- paste('S(\"X\" | ', .dgsa$parameters[.paramIndex], ')', sep=\"\")\n  } else {\n    .ggDATA <- apply(.dgsa$sensitivityMatrix, 1, diag)\n    .plotTitle <- 'Main Sensitivities (marginal)'\n  }\n\n  colnames(.ggDATA) <- paste('Cluster', 1:ncol(.ggDATA), sep=\"_\")\n  .ggDATA[is.nan(.ggDATA)] = 0\n\n  .ggDATA <- as.data.frame(.ggDATA)\n\n  .ggDATA$mean <- apply(.ggDATA, 1, mean)\n\n  .ggDATA$parameters <- .dgsa$parameters\n\n  # order by mean:\n  .ggDATA <- .ggDATA[order(.ggDATA$mean), ]\n  .levels <- .ggDATA$parameters\n\n  .ggDATA <- melt(.ggDATA, id=c(\"parameters\"))\n  .ggDATA$parameters <- factor(.ggDATA$parameters, levels = .levels)\n\n  .ggP <- ggplot(.ggDATA, aes(x=parameters, y = value, fill = variable)) + coord_flip() +\n    geom_bar(stat = \"identity\", position = \"dodge\", lwd = 0.2, colour = \"black\") +\n    theme(legend.position=\"bottom\") + geom_hline(yintercept = ifelse(.hypothesis, 1, NULL)) + ggtitle(.plotTitle)\n\nif(.ggReturn){\n  return(.ggP)\n} else {\n  print(.ggP)\n}\n\n}\n\n# Write documentation. package. vignette. github.....\n# Need to speed up bootstrap.\n\n#' @title plots CDF's\n#'\n#' @param .X           - A matrix of input parameters\n#' @param .clusters    - A vector of cluster tags.\n#' @param .interaction - specify which interaction to plot i.e. \"a|b\", both \"a\" and \"b\"\n#'                       have to be parameters names already present in the dataset.\n#' @param .ggReturn    - whether or not to return a ggplot structure (for adjustments)\n#'\n#' @details This code uses ggplot for plotting it will throw out a very basic plot\n#'\n#' @author  Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\n#'\nplotCDFS <- function(.clustering, .X, .code = NULL,  .nBins = 3, .ggReturn = 'plot', lwd=1){\n\n\n  .cbbPalette <- c(\"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")\n\nif(.code == \"all*\"){\n\n  .ggDATA <- rbind.data.frame(data.frame(.X, clustering = \"prior\"),\n                              data.frame(.X, clustering = as.character(.clustering))\n  )\n\n  .ggDATA$clustering <- factor(.ggDATA$clustering, levels = c(as.character(unique(.clustering)), 'prior'))\n\n  .ggDATA <- melt(.ggDATA, id = c(\"clustering\"))\n\n  .gg <- ggplot(.ggDATA) + stat_ecdf(aes(x=value, group = clustering, colour = clustering), lwd=lwd) +\n         ylab('Phi') + ylim(c(0,1)) + theme(legend.position = \"top\") + xlab('parameter range') +\n         scale_colour_manual(values = c(.cbbPalette[1:length(unique(.clustering))], \"#000000\")) +\n         # scale_colour_manual(values = c(scales::hue_pal()(length(unique(.clustering))), \"#000000\")) +\n         facet_wrap(~variable, scales=\"free_x\")\n\n} else {\n  .params <- strsplit(.code, \"|\", fixed = TRUE)[[1]]\n\n  if(length(.params) == 0 | length(.params) >2) stop('\".code\" is invalid!')\n\n  .paramIndex <- apply(as.matrix(.params), 1, function(x) which(colnames(.X) %in% x))\n\n  if(length(.paramIndex) != length(.params)) stop('\".code\" is invalid, one or both of the variables were not found!')\n\n    if(length(.paramIndex) == 1){ # single mode....\n\n      .ggDATA <- rbind.data.frame(data.frame(parameter  = .X[,.paramIndex], clustering = \"prior\"),\n                                  data.frame(parameter  = .X[,.paramIndex], clustering = as.character(.clustering))\n      )\n\n     .ggDATA$clustering <- factor(.ggDATA$clustering, levels = c(as.character(unique(.clustering)), 'prior'))\n\n     .gg <- ggplot(.ggDATA) + stat_ecdf(aes(x=parameter, group = clustering, colour = clustering), lwd=lwd) +\n            xlab(colnames(.X)[.paramIndex]) + ylab('Phi') + ylim(c(0,1)) + theme(legend.position = \"top\") +\n            scale_colour_manual(values = c(.cbbPalette[1:length(unique(.clustering))], \"#000000\"))\n#             scale_colour_manual(values = c(scales::hue_pal()(length(unique(.clustering))), \"#000000\"))\n\n    } else {\n\n      .brks = quantile(.X[, .paramIndex[2]], seq(0, 1, 1/.nBins))\n\n        if(length(unique(round(.brks,8))) > 1){\n\n          .binning  <- cut(.X[,.paramIndex[2]],\n                           breaks = .brks,\n                           include.lowest = TRUE, right = TRUE, labels = FALSE)\n\n        } else {\n            stop(paste('It appears that something is wrong with parameter: ', colnames(.X)[.paramIndex[2]]))\n        }\n\n\n      .ggDATA <- rbind.data.frame(\n\n                            data.frame(parameter  = .X[,.paramIndex[1]],\n                                       clustering = paste('Cluster_', .clustering, sep=\"\"),\n                                       bin        = .binning),\n\n                            data.frame(parameter  = .X[,.paramIndex[1]],\n                                       clustering = paste('Cluster_', .clustering, sep=\"\"),\n                                       bin        = 'cluster_prior'\n                                       )\n      )\n\n      .ggDATA$bin <- factor(.ggDATA$bin, levels = c(unique(.binning), 'cluster_prior'))\n\n      .gg <- ggplot(.ggDATA) + stat_ecdf(aes(x=parameter, group = bin, colour = bin), lwd=lwd) +\n             xlab(.code) + ylab('Phi') + ylim(c(0,1)) + theme(legend.position = \"top\") +\n             facet_grid(~clustering) +\n             scale_colour_manual(values = c(scales::hue_pal()(length(unique(.binning))), \"#000000\"))\n\n    }\n}\n\n.gg <- .gg + ggtitle(paste('CDFs for ', .code))\n\nif(.ggReturn == \"plot\") {\n  print(.gg)\n} else {\n  return(.gg)\n}\n\n}\n\n#' @title plots scaled scatter plots of inputs on provided low dimmensional representation\n#'\n#' @param .inputs   - A data frame with input parameters stacked in columns\n#' @param .coords   - Coordinates matrix (only the first two columns matter), from cmdscale or pca analysis\n#' @param .clusters - Optional clustering vector that puts different shape on different cluster\n#' @param .ggReturn - Whether to return ggplot structure or not.\n#' @param .cb       - Whether to plot with colour blind friendly palette (default = FALSE)\n#' @details It plots a ggplot with facet wrap of all input parameters.\n#'\n#' @author Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\nplotDGSAscatter <- function(.inputs, .coords, .clusters = NULL, .ggReturn = FALSE, .cb=FALSE){\n\n  if(is.null(.inputs)) stop(\"Inputs data frame was not provided. Exiting!\")\n  if(is.null(.coords)) stop(\"Coordinates matrix was not provided! Exiting!\")\n\n\n  if(.cb){\n    .COLS <- c(\"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\")\n  } else {\n    .COLS <- rainbow(9)\n  }\n\n  .ggData    <- as.data.frame(apply(.inputs, 2, scaleInp))\n  .ggData$x1 <- .coords[,1]\n  .ggData$x2 <- .coords[,2]\n\n  if(!is.null(.clusters)) {\n    .ggData$clusters = .clusters\n  } else {\n    .ggData    <- melt(.ggData, id=c(\"x1\",\"x2\"))\n    .ggP       <- ggplot(.ggData) + geom_point(aes(x=x1, y=x2, colour=value)) +\n      facet_wrap(~variable) + scale_colour_gradientn(colours= .COLS, breaks = c(0,1), labels = c(\"Low\",\"High\"))\n\n\n#       scale_colour_gradientn(colours=rainbow(9), breaks = c(0,1), labels = c(\"Low\",\"High\"))\n  }\n\n  if(.ggReturn){\n    return(.ggP)\n  } else {\n    print(.ggP)\n  }\n\n}\n\n\n#' @title plots scaled scatter plots of inputs on provided low dimmensional representation\n#'\n#' @param .X        - A data frame with input parameters stacked in columns\n#' @param .coords   - Coordinates matrix (only the first two columns matter), from cmdscale or pca analysis\n#' @param .lineData - are you plotting line data\n#' @param .code     - parameter you wish to plot\n#' @param .ggReturn - Whether to return ggplot structure or not.\n#' @param .nBins    - number of bins to analyze\n#'\n#' @details It plots a ggplot with facet wrap of all input parameters.\n#'\n#' @author Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\nplotDGSAconditioalScatter <- function(.X, .coords, .lineData = FALSE, .code = NULL, .time = NULL, .nBins = 3, .ggReturn = FALSE, .theme = NULL){\n\n  .params <- strsplit(.code, \"|\", fixed = TRUE)[[1]]\n\n  if(length(.params) == 0 | length(.params) >2) stop('\".code\" is invalid!')\n\n  .paramIndex <- apply(as.matrix(.params), 1, function(x) which(colnames(.X) %in% x))\n\n  if(length(.paramIndex) != length(.params)) stop('\".code\" is invalid, variable was not found!')\n\n  if(length(.paramIndex) == 1){ # single mode....\n\n    .brks = quantile(.X[, .paramIndex], seq(0, 1, 1/.nBins))\n\n    if(length(unique(round(.brks,8))) > 1){\n\n      .binning  <- cut(.X[,.paramIndex],\n                       breaks = .brks,\n                       include.lowest = TRUE, right = TRUE, labels = FALSE)\n\n    } else {\n      stop(paste('It appears that something is wrong with parameter: ', colnames(.X)[.paramIndex[2]]))\n    }\n\n    if(.lineData){\n\n      .coords <- as.data.frame(.coords)\n\n       if(!is.null(.time)) {\n         .coords$Time <- .time\n       } else {\n         .coords$Time <- 1:nrow(.coords)\n       }\n\n      .ggBASE <- melt(.coords, id=\"Time\")\n\n      .ggDATA <- NULL\n\n      for(i in 1:.nBins){\n\n        .ggDATA <- rbind.data.frame(.ggDATA,\n                                    cbind.data.frame(.ggBASE,\n                                                     bining = 0,\n                                                     bin = paste(\"Bin\",i)),\n                                    cbind.data.frame(melt(.coords[,c(.binning == i, TRUE)], id=\"Time\"),\n                                                     bining = 1,\n                                                     bin = paste(\"Bin\",i)))\n      }\n\n      .ggDATA$bining <- c(\"allData\", \"binData\")[.ggDATA$bining+1]\n      .ggDATA$bining <- factor(.ggDATA$bining, levels=c(\"allData\", \"binData\"))\n      .ggDATA$bin <- factor(.ggDATA$bin)\n\n      .gg <- ggplot(.ggDATA) + geom_line(aes(x=Time, y=value, group=variable, colour=bining, alpha = bining)) + facet_grid(~bin) +\n      theme(legend.position=\"top\") + ggtitle(paste(\"Binning for parameter\", colnames(.X)[.paramIndex])) +\n        scale_alpha_manual(values = c(0.1,1))  + .theme +\n        scale_colour_manual(values=c(\"#000000\", \"#E69F00\"))\n\n    } else {\n\n    .ggDATA = NULL\n\n    for(i in 1:.nBins){\n\n      .ggDATA <- rbind.data.frame(.ggDATA,\n                                  data.frame(X1  = .coords[,1],\n                                             X2  = .coords[,2],\n                                             bining = 0,\n                                             bin = paste(\"Bin\",i)),\n                                  data.frame(X1  = .coords[.binning == i,1],\n                                             X2  = .coords[.binning == i,2],\n                                             bining = 1,\n                                             bin = paste(\"Bin\",i)))\n      }\n\n      .ggDATA$bining <- c(\"allData\", \"binData\")[.ggDATA$bining+1]\n      .ggDATA$bining <- factor(.ggDATA$bining, levels=c(\"allData\", \"binData\"))\n      .ggDATA$bin <- factor(.ggDATA$bin)\n\n      .gg <- ggplot(.ggDATA) + geom_point(aes(x=X1, y=X2, colour = bining, shape=bining, size=bining)) + facet_grid(~bin) +\n             theme(legend.position=\"top\") + ggtitle(paste(\"Binning for parameter\", colnames(.X)[.paramIndex])) + .theme +\n             scale_colour_manual(values=c(\"#000000\", \"#E69F00\")) + scale_shape_manual(values=c(5, 16)) + scale_size_manual(values=c(3,1))\n    }\n\n  } else { # dual mode:\n\n    .brks1 = quantile(.X[, .paramIndex[1]], seq(0, 1, 1/.nBins))\n    .brks2 = quantile(.X[, .paramIndex[2]], seq(0, 1, 1/.nBins))\n\n    if(length(unique(round(.brks1,8))) > 1 && length(unique(round(.brks2,8))) > 1){\n\n      .binning1  <- cut(.X[,.paramIndex[1]],\n                       breaks = .brks1,\n                       include.lowest = TRUE, right = TRUE, labels = FALSE)\n      .binning2  <- cut(.X[,.paramIndex[2]],\n                        breaks = .brks2,\n                        include.lowest = TRUE, right = TRUE, labels = FALSE)\n    } else {\n      stop(paste('It appears that something is wrong with parameter: ', colnames(.X)[.paramIndex[2]]))\n    }\n\n    if(.lineData){\n\n      .coords <- as.data.frame(.coords)\n\n      if(!is.null(.time)) {\n        .coords$Time <- .time\n      } else {\n        .coords$Time <- 1:nrow(.coords)\n      }\n\n      .ggBASE <- melt(.coords, id=\"Time\")\n\n      .ggDATA <- NULL\n\n      for(i in 1:.nBins){\n        for(j in 1:.nBins){\n\n          .cIndices <- as.logical(c((.binning1 == i) * (.binning2 == j), TRUE))\n\n          .ggDATA <- rbind.data.frame(.ggDATA,\n                                      cbind.data.frame(.ggBASE,\n                                                       bining = 0,\n                                                       bin1 = paste(colnames(.X)[.paramIndex[1]], \"bin\", i),\n                                                       bin2 = paste(colnames(.X)[.paramIndex[2]], \"bin\", j)),\n                                      cbind.data.frame(melt(.coords[,.cIndices], id=\"Time\"),\n                                                       bining = 1,\n                                                       bin1 = paste(colnames(.X)[.paramIndex[1]], \"bin\", i),\n                                                       bin2 = paste(colnames(.X)[.paramIndex[2]], \"bin\", j)))\n        }\n      }\n\n      .ggDATA$bining <- c(\"allData\", \"binData\")[.ggDATA$bining+1]\n      .ggDATA$bining <- factor(.ggDATA$bining, levels=c(\"allData\", \"binData\"))\n      .ggDATA$bin1 <- factor(.ggDATA$bin1)\n      .ggDATA$bin2 <- factor(.ggDATA$bin2)\n\n      .gg <- ggplot(.ggDATA) + geom_line(aes(x=Time, y=value, group=variable, colour=bining, alpha = bining)) +\n        facet_grid(bin1~bin2) + theme(legend.position=\"top\") +\n        ggtitle(paste(\"Binning for parameters\", .code)) +\n        scale_alpha_manual(values = c(0.1,1))  + .theme +\n        scale_colour_manual(values=c(\"#000000\", \"#E69F00\"))\n\n    }\n\n  }\n     if(.ggReturn){\n       return(.gg)\n     } else {\n       plot(.gg)\n     }\n}\n\n\n#' @title Scales input parameters to 0,1 scale\n#' @param .Input - Input vector to scale\n#' @param .lB    - Lower bound if other than minimum\n#' @param .uB    - Upper bound if other than maximum\n#'\n#' @author Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\nscaleInp <- function(.Input, .lB = NULL, .uB = NULL){\n\n  if(is.null(.lB)) {\n    .lB   <- min(.Input)\n  }\n\n  if(is.null(.uB)) {\n    .uB   <- max(.Input)\n  }\n\n  .output <- (.Input - .lB) / (.uB - .lB)\n\n  return(.output)\n\n}\n\n\n",
    "created" : 1477702129079.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3353993816",
    "id" : "2A3C7647",
    "lastKnownWriteTime" : 1478106641,
    "path" : "~/Google Drive/Functional_Research/DGSA/R/main.R",
    "project_path" : "R/main.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}