{
    "contents" : "# Final Test Code:\nlibrary(DGSA)\n\n# setwd(\"~/Google Drive/Functional_Research/DGSA\")\n# source(\"./R/main.R\")\n\nINPUT         <- read.csv(\"./data/Input.csv\")\nOUTPUT.damage <- read.csv(\"./data/Output_damage.csv\")\n\ncomps  <- prcomp(OUTPUT.damage)\nscores <- t(t(comps$x[,1:2])/comps$sdev[1:2])\nclustering = kmeans(scores, 2, 50)$cluster\nplot(scores)\npoints(scores[clustering == 1,], col=\"red\", pch = 19)\npoints(scores[clustering == 2,], col=\"blue\", pch=19)\n\n# EDA for DGSA:\nplotCDFS(clustering, INPUT, .code = \"all*\")\nplotCDFS(clustering, INPUT, .code = \"beta\")\nplotCDFS(clustering, INPUT, .code = \"lambda\")\nplotCDFS(clustering, INPUT, .code = \"beta|lambda\", .nBins = 2)\nplotCDFS(clustering, INPUT, .code = \"lambda|beta\", .nBins = 2)\n\n\n# run DGSA:\nsystem.time(myDGSA <- dgsa(clustering, INPUT, .normalize = TRUE, .interactions = TRUE, .nBoot = 100))\nplotMatrixDGSA(myDGSA)\nplotMatrixDGSA(myDGSA, .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single')\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', tl.srt = 65)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE, tl.srt = 65)\n\nplotMatrixDGSA(myDGSA, .method = \"circle\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"number\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"square\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"shade\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", type = \"lower\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", type = \"upper\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"circle\", diag=TRUE, .hypothesis = TRUE, tl.srt = 45,\n               insig = \"pch\", pch = \"+\", pch.col = \"black\", pch.cex = 1.5)\n\nplotParetoDGSA(myDGSA)\nplotParetoDGSA(myDGSA, .interaction = \"beta\")\nplotParetoDGSA(myDGSA, .interaction = \"lambda\")\n\n\n\n# Trees are much more robust in a sense that you are averaging over all splits and all trees.\n# Therefore sensitivities are always consistent. In dgsa they are not!\n\n\n# Shale Dataset:\nlibrary(DGSA)\nload(\"~/Google Drive/Functional_Research/TreeS_workingDir/TreeS_workingDir/RealDataSetScaled.Rdata\")\n\nCovCompletion <- Reservoir1_allCovariates[,colnames(covariatesCompletion)]\nCovCompletion <- cbind(CovCompletion,Reservoir1_allCovariates$GeolX_Rel, Reservoir1_allCovariates$GeolY_Rel )\ncolnames(CovCompletion) <- c(colnames(covariatesCompletion), \"GeolX_Rel\", \"GeolY_Rel\")\n\ncomps  <- prcomp(t(completeSet))\nscores <- t(t(comps$x[,1:2])/comps$sdev[1:2])\nclustering = kmeans(scores, 2, 50)$cluster\nplot(scores)\npoints(scores[clustering == 1,], col=\"red\", pch = 19)\npoints(scores[clustering == 2,], col=\"blue\", pch=19)\n\n# EDA for DGSA:\n\n# colnames(CovCompletion)\n# [1] \"Geol3DSpacing\"                 \"GeolAPIGrav\"                   \"ProdVert200\"\n# [4] \"ProdVert300\"                   \"ProdVertVin200\"                \"ProdVertVin300\"\n# [7] \"ComplStagesPumped\"             \"ComplStageInterval\"            \"ComplFluid\"\n# [10] \"ComplProppant\"                 \"ComplAvgRate\"                  \"ComplAvgPress\"\n# [13] \"DrillWellTort\"                 \"CMP_LATERAL_LENGTH\"            \"CMP_STIMULATED_LATERAL_LENGTH\"\n# [16] \"CMP_STAGES_STIMULATED\"         \"CMP_AVERAGE_INTERVAL\"          \"CMP_AVG_BREAK_PRESSURE\"\n# [19] \"CMP_TOTAL_FLUID_STIM\"          \"CMP_CLEAN_FLUID_TOTAL\"         \"CMP_TOTAL_PROPPANT_USED\"\n# [22] \"CMP_BAKE_TIME.days.\"           \"GeolX_Rel\"                     \"GeolY_Rel\"\n#\nCovCompletion <- CovCompletion[,-which(colnames(CovCompletion) %in% c(\"ProdVertVin200\", \"ProdVertVin300\", \"CMP_AVG_BREAK_PRESSURE\"))]\nplotCDFS(clustering, CovCompletion, .code = \"all*\")\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav\")\nplotCDFS(clustering, CovCompletion, .code = \"CMP_STIMULATED_LATERAL_LENGTH\")\nplotCDFS(clustering, CovCompletion, .code = \"CMP_STIMULATED_LATERAL_LENGTH|GeolX_Rel\", .nBins = 2)\nplotCDFS(clustering, CovCompletion, .code = \"ProdVertVin200|CMP_BAKE_TIME.days.\", .nBins = 2)\nplotCDFS(clustering, CovCompletion, .code = \"CMP_STIMULATED_LATERAL_LENGTH|ProdVertVin200\", .nBins = 2)\nplotCDFS(clustering, CovCompletion, .code = \"ProdVert200|CMP_STIMULATED_LATERAL_LENGTH\", .nBins = 2)\nplotCDFS(clustering, CovCompletion, .code = \"ProdVertVin200\")\nplotCDFS(clustering, CovCompletion, .code = \"ProdVert200\")\nplotCDFS(clustering, CovCompletion, .code = \"GeolY_Rel\")\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav\")\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav|GeolY_Rel\")\nplotCDFS(clustering, CovCompletion, .code = \"GeolY_Rel|GeolAPIGrav\")\n\n# run DGSA:\nmyDGSA <- DGSA::dgsa(clustering, CovCompletion, .interactions = TRUE, .nBoot = 100)\nplotMatrixDGSA(myDGSA)\nplotMatrixDGSA(myDGSA, .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single')\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', tl.srt = 65)\nplotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE, tl.srt = 65)\n\nplotMatrixDGSA(myDGSA, .method = \"circle\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"number\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"square\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"shade\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", type = \"lower\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"pie\", type = \"upper\", .hypothesis = FALSE)\nplotMatrixDGSA(myDGSA, .method = \"circle\", order = 'hclust', hclust.method='centroid',\n               diag=TRUE, .hypothesis = TRUE, tl.srt = 90,\n               insig = \"pch\", pch = \"*\", pch.col = \"blue\", pch.cex = 1.5)\n\n\nplotCDFS(clustering, CovCompletion, .code = \"CMP_STIMULATED_LATERAL_LENGTH|GeolAPIGrav\", .nBins = 3)\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav|CMP_STIMULATED_LATERAL_LENGTH\", .nBins = 3)\n\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav|GeolY_Rel\", .nBins = 3)\nplotCDFS(clustering, CovCompletion, .code = \"GeolY_Rel|GeolAPIGrav\", .nBins = 3)\n\n\nplotCDFS(clustering, CovCompletion, .code = \"GeolY_Rel\", .nBins = 2)\nplotCDFS(clustering, CovCompletion, .code = \"GeolAPIGrav\", .nBins = 2)\n\nplot(CovCompletion$GeolY_Rel, CovCompletion$GeolAPIGrav,\n     main = paste(\"Correlation Coef:\" ,round(cor(CovCompletion$GeolY_Rel, CovCompletion$GeolAPIGrav),2)))\n\nplotParetoDGSA(myDGSA)\nplotParetoDGSA(myDGSA, .interaction = \"beta\")\nplotParetoDGSA(myDGSA, .interaction = \"lambda\")\n\n\n### Boostrapping by considering clustering as well.\nINPUT         <- read.csv(\"./data/Input.csv\")\nOUTPUT.damage <- read.csv(\"./data/Output_damage.csv\")\n\ncomps  <- prcomp(OUTPUT.damage)\nscores <- t(t(comps$x[,1:2])/comps$sdev[1:2])\nclustering = kmeans(scores, 2, 50)$cluster\nbaseDGSA <- dgsa(clustering, INPUT, .normalize = FALSE, .interactions = TRUE, .nBoot = 100, .progress = TRUE)\n\nlibrary(doParallel)\nlibrary(foreach)\n\ncl <- makeCluster(8)\nregisterDoParallel(cl)\n\nbootList <- foreach(c.seed = 1:500, .packages = c('DGSA')) %dopar% {\n\n  set.seed(c.seed)\n  sampleInd <- sample(nrow(INPUT), nrow(INPUT), replace=TRUE)\n\n\n  dgsa(clustering[sampleInd], INPUT[sampleInd,], .normalize = FALSE,.interactions = TRUE, .nBoot = 100, .progress=FALSE)\n\n}\nstopCluster(cl)\n\nbootExtractCL1 <- sapply(bootList, function(x) x$sensitivityMatrix[1,,], simplify = 'array')\nbootExtractCL2 <- sapply(bootList, function(x) x$sensitivityMatrix[2,,], simplify = 'array')\n\ncl1Normalizer  <- apply(bootExtractCL1, c(1,2), function(x){\n  if(any(is.na(x))){\n    return(NaN)\n  } else {\n    quantile(x, 0.95)\n  }\n}\n)\n\ncl2Normalizer  <- apply(bootExtractCL2, c(1,2), function(x){\n  if(any(is.na(x))){\n    return(NaN)\n  } else {\n    quantile(x, 0.95)\n  }\n}\n)\n\nnormalizerMatrix      <- baseDGSA$sensitivityMatrix\nnormalizerMatrix[1,,] <- cl1Normalizer\nnormalizerMatrix[2,,] <- cl2Normalizer\n\nnormalizedSensitivity <- baseDGSA\nnormalizedSensitivity$sensitivityMatrix <- normalizedSensitivity$sensitivityMatrix / normalizerMatrix\noriginalDGSA <- dgsa(clustering, INPUT, .normalize = TRUE, .interactions = TRUE, .nBoot = 500, .progress = TRUE)\nclass(normalizedSensitivity) <- class(originalDGSA)\n\nplotMatrixDGSA(originalDGSA, .hypothesis = FALSE)\nplotMatrixDGSA(normalizedSensitivity, .hypothesis = FALSE)\n\n\n\n",
    "created" : 1476999339707.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "48105818",
    "id" : "79FEF1EA",
    "lastKnownWriteTime" : 1478106808,
    "path" : "~/Google Drive/Functional_Research/DGSA/finalTestCode.R",
    "project_path" : "finalTestCode.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}