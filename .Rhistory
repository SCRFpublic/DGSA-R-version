insig = "pch", pch = "+", pch.col="red", pch.cex=0.8)
insig = "pch", pch = "+", pch.col="red", pch.cex=1)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="red", pch.cex=1)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="red", pch.cex=2)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="red", pch.cex=1,5)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="red", pch.cex=1.5)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="black", pch.cex=1.5)
plotMatrixDGSA(myDGSA, .method = "shade", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "circle", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col="black", pch.cex=1.5)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE,
insig = "pch", pch = "+", pch.col = "black", pch.cex = 1.5)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE, tl.srt = 45,
insig = "pch", pch = "+", pch.col = "black", pch.cex = 1.5)
library(roxygen2)
library(devtools)
devtools::document()
setwd("~/Google Drive/Functional_Research/DGSA")
devtools::document()
library(DGSA)
library(DGSA)
library(DGSA)
setwd("~/Google Drive/Functional_Research/DGSA")
source("./R/main.R")
library(DGSA)
INPUT         <- read.csv("./data/Input.csv")
OUTPUT.damage <- read.csv("./data/Output_damage.csv")
comps  <- prcomp(OUTPUT.damage)
scores <- t(t(comps$x[,1:2])/comps$sdev[1:2])
clustering = kmeans(scores, 2, 50)$cluster
plot(scores)
points(scores[clustering == 1,], col="red", pch = 19)
points(scores[clustering == 2,], col="blue", pch=19)
# EDA for DGSA:
plotCDFS(clustering, INPUT, .code = "all*")
plotCDFS(clustering, INPUT, .code = "beta")
plotCDFS(clustering, INPUT, .code = "lambda")
plotCDFS(clustering, INPUT, .code = "beta|lambda", .nBins = 2)
# run DGSA:
myDGSA <- dgsa(clustering, INPUT, .interactions = TRUE)
plotMatrixDGSA(myDGSA)
plotMatrixDGSA(myDGSA, .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single')
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', tl.srt = 65)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE, tl.srt = 65)
plotMatrixDGSA(myDGSA, .method = "circle", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "number", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "square", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "shade", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "pie", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "pie", type = "lower", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "pie", type = "upper", .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, .method = "circle", diag=TRUE, .hypothesis = TRUE, tl.srt = 45,
insig = "pch", pch = "+", pch.col = "black", pch.cex = 1.5)
saveRDS(myDGSA, file="./vignette/myDGSA")
help(dgsa)
help("plotMatrixDGSA")
plotParetoDGSA(myDGSA)
plotParetoDGSA(myDGSA, .interaction = "beta")
plotParetoDGSA(myDGSA, .interaction = "lambda")
idea1 <- function(){
bootMatrix <- matrix(NA, c(ncol(.PARAMETERS), .nBoot));
for(j in 1:.nBoot){
bootMatrix[i,j] <- colSums(
abs(.priors - apply(.PARAMETERS[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01))  )
}
}
idea1 <- function(){
bootMatrix <- matrix(NA, c(ncol(priors), 1000))
for(j in 1:1000){
bootMatrix[i,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
}
idea1 <- function(){
bootMatrix <- matrix(NA, c(ncol(priors), 1000))
for(j in 1:1000){
set.seed(j)
bootMatrix[i,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
return(bootMatrix)
}
idea1 <- function(){
bootMatrix <- matrix(NA, c(1, 1000))
for(j in 1:1000){
set.seed(j)
bootMatrix[1,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
return(bootMatrix)
}
priors <- apply(INPUT,2, function(x) quantile(x, seq(0,1,0.01)))
N = ncol(priors)
idea1
idea1()
bootMatrix <- matrix(NA, c(1, 1000))
for(j in 1:1000){
set.seed(j)
bootMatrix[1,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
j=1
set.seed(j)
bootMatrix[1,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
N
priors <- apply(INPUT,2, function(x) quantile(x, seq(0,1,0.01)))
N = nrow(priors)
bootMatrix <- matrix(NA, c(1, 1000))
for(j in 1:1000){
set.seed(j)
bootMatrix[1,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
dim(priors)
dim(apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
)
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
)
colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
bootMatrix[1,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
bootMatrix <- matrix(NA, nrow = 1, ncol = 1000))
bootMatrix <- matrix(NA, nrow = 1, ncol = 1000)
for(j in 1:1000){
set.seed(j)
bootMatrix[j,1] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
set.seed(j)
bootMatrix[j,1] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
bootMatrix[j,1]
bootMatrix <- matrix(NA, nrow = 1, ncol = 1000)
bootMatrix
bootMatrix <- matrix(NA, nrow = 13, ncol = 1000)
dim(bootMatrix)
bootMatrix <- matrix(NA, nrow = 13, ncol = 1000)
set.seed(j)
bootMatrix[,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
idea1 <- function(){
bootMatrix <- matrix(NA, nrow = 13, ncol = 1000)
for(j in 1:1000){
set.seed(j)
bootMatrix[,j] <- colSums(
abs(priors - apply(INPUT[sample(N,50, replace=FALSE),], 2,
function(x) quantile(x, seq(0, 1, 0.01)))
))
}
return(bootMatrix)
}
idea1()
microbenchmark(idea1())
library(microbenchmark)
microbenchmark(idea1())
bootMat <- array(sample(50*13*1000), c(50,13,1000))
bootMat[1,2,1]
bootMat[1,2,]
bootMat[1,,1]
bootMat[,,1]
bootMat <- INPUT[bootMat, 1]
dim(bootMat)
bootMat
is.matrix(bootMat)
is.array(bootMat)
bootMat[1,1,1]
system.time(colQuantileC(INPUT, 0.95))
install.packages('WGCNA')
library(WGCNA)
system.time(colQuantileC(INPUT, 0.95))
library(WGCNA)
install.packages('impute')
library(WGCNA)
library(impute)
install.packages('impute')
help(install.packages)
install.packages("~/Desktop/Multivariate Random Forest/impute/", repos=NULL, , type="source")
install.packages("~/Desktop/Multivariate Random Forest/impute_1.48.0.tgz", repos=NULL, , type="source")
install_github('andreacirilloac/updateR')
install.packages('updateR')
library(DGSA)
load("~/Google Drive/Functional_Research/TreeS_workingDir/TreeS_workingDir/RealDataSetScaled.Rdata")
CovCompletion <- Reservoir1_allCovariates[,colnames(covariatesCompletion)]
CovCompletion <- cbind(CovCompletion,Reservoir1_allCovariates$GeolX_Rel, Reservoir1_allCovariates$GeolY_Rel )
colnames(CovCompletion) <- c(colnames(covariatesCompletion), "GeolX_Rel", "GeolY_Rel")
comps  <- prcomp(t(completeSet))
scores <- t(t(comps$x[,1:2])/comps$sdev[1:2])
clustering = kmeans(scores, 2, 50)$cluster
plot(scores)
points(scores[clustering == 1,], col="red", pch = 19)
points(scores[clustering == 2,], col="blue", pch=19)
CovCompletion <- CovCompletion[,-which(colnames(CovCompletion) %in% c("ProdVertVin200", "ProdVertVin300", "CMP_AVG_BREAK_PRESSURE"))]
plotCDFS(clustering, CovCompletion, .code = "GeolY_Rel")
plotCDFS(clustering, CovCompletion, .code = "GeolAPIGrav")
plotCDFS(clustering, CovCompletion, .code = "GeolAPIGrav|GeolY_Rel")
plotCDFS(clustering, CovCompletion, .code = "GeolY_Rel|GeolAPIGrav")
library(fda)
library(functInterp)
library(functionalTrees)
library(corrplot)
library(PerformanceAnalytics)
library(DGSA)
universalTheme = theme_grey() +
theme(axis.line = element_line(size = 0.5, colour = "black"),
axis.text = element_text(size = 15, face='bold'),
axis.title.x = element_text(size = 15, face='bold'),
axis.title.y = element_text(size = 15, colour='black', face='bold'),
strip.text.x = element_text(size = 15, colour = "black", face='bold'),
strip.text.y = element_text(size = 15, colour = "black", face='bold'),
strip.background = element_rect(fill="orange"),
legend.position = "bottom",
legend.text=element_text(size=12, face = "bold"),
legend.title=element_text(size=14),
panel.border = element_rect(colour = "black", fill=NA, size=1))
# load the data:
setwd("~/Google Drive/Functional_Research/Earthquake_sensitivity")
# Read the data:
allINPUTS <- read.csv("./Data/Analysis2B/input_output_10272016/input_1500sim_10272016.csv")
# Rupture Module:
ruptureINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_rupture_1500sim_10272016.csv")
# Ground motion module:
groundMotionINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_GM_1500sim_10272016.csv")
# Damage module:
damageINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_damage_1500sim_10272016.csv")
# Intermediate OUTPUTS:
damageOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_damage_1500sim_10272016.csv")
groundMotionOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_GM_1500sim_10272016.csv", header=FALSE)
# Final OUTPUTS:
lossOUTPUT   <- read.csv("./Data/Analysis2B/input_output_10272016/output_loss_1500sim_10272016.csv", header = FALSE)
injuryOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_injuries_1500sim_10272016.csv")
library(Rcpp)
library(RcppArmadillo)
sourceCpp("./Scripts/klDivergenceCpp.cpp")
cppKLdiv <- function(.object, eps=10^-4,...){
if(!is.numeric(.object))
stop("object must be a numeric matrix\n")
w <- .object < eps
if (any(w)) .object[w] <- eps
.object <- sweep(.object, 2, colSums(.object) , "/")
.z <- KL_divergence(.object, rep(1,nrow(.object)))
colnames(.z) <- rownames(.z) <- colnames(.object)
.z
}
MmedInputs        <- allINPUTS[,6:9]
MmedInputs.prcomp <- princomp(MmedInputs, cor=FALSE)
allINPUTSfixed <- allINPUTS
allINPUTSfixed[,6:9] <- MmedInputs.prcomp$scores
# We have to keep all of them!
colnames(allINPUTSfixed)[6:9] <- c("IM_pc1","IM_pc2","IM_pc3","IM_pc4")
damage.mds  <- cmdscale(damage.dist, eig=TRUE, k=2)
damage.dist <- dist(damageOUTPUT[,-5]);
damage.clustering = kmeans(damage.mds$points, 2, 50)$cluster
damage.dist <- dist(damageOUTPUT[,-5]);
damage.mds  <- cmdscale(damage.dist, eig=TRUE, k=2)
damage.clustering = kmeans(damage.mds$points, 2, 50)$cluster
loss.KL.clustering <- damage.clustering
print(plotCDFS(loss.KL.clustering, allINPUTSfixed, .code="IM_pc4*", .ggReturn = TRUE) + universalTheme)
head(allINPUTSfixed)
print(plotCDFS(loss.KL.clustering, allINPUTSfixed, .code="IM_pc4", .ggReturn = TRUE) + universalTheme)
lossScalar    <- data.frame(x=lossOUTPUT[,1])
lossX         <- t(lossOUTPUT[1,2:10002])
lossY         <- t(lossOUTPUT[,10003:20003])
lossY[is.nan(lossY)] <- 0
lossY[lossY<10e-04] = 10e-04
loss.KL.dist <- cppKLdiv(lossY)
loss.KL.mds  <- cmdscale(loss.KL.dist, eig=TRUE, k=8)
loss.KL.clustering = kmeans(loss.KL.mds$points, 2, 50)$cluster
plot(cumsum(loss.KL.mds$eig[1:10]/sum(loss.KL.mds$eig[1:10])), type = "b", col="blue",
xlab = "Number of PCs", ylab = "fraction of variance explained")
print(plotDGSAscatter(allINPUTSfixed, loss.KL.mds$points, .ggReturn = TRUE) + universalTheme)
loss.KL.dist <- as.matrix(loss.KL.dist)
loss.JS.dist <- 0.5*loss.KL.dist + 0.5*t(loss.KL.dist)
loss.JS.mds  <- cmdscale(loss.JS.dist, eig=TRUE, k=3)
plot(cumsum(loss.JS.mds$eig[1:10]/sum(loss.JS.mds$eig[1:10])), type = "b", col="blue",
xlab = "Number of PCs", ylab = "fraction of variance explained")
loss.JS.clustering = kmeans(loss.JS.mds$points, 2, 50)$cluster
print(plotDGSAscatter(allINPUTSfixed, loss.JS.mds$points, .ggReturn = TRUE) + universalTheme)
print(plotCDFS(loss.JS.clustering, allINPUTSfixed, .code="all*", .ggReturn = TRUE) + universalTheme)
print(plotCDFS(loss.KL.clustering, allINPUTSfixed, .code="IM_pc4", .ggReturn = TRUE) + universalTheme)
library(fda)
library(functInterp)
library(functionalTrees)
library(corrplot)
library(PerformanceAnalytics)
library(DGSA)
universalTheme = theme_grey() +
theme(axis.line = element_line(size = 0.5, colour = "black"),
axis.text = element_text(size = 15, face='bold'),
axis.title.x = element_text(size = 15, face='bold'),
axis.title.y = element_text(size = 15, colour='black', face='bold'),
strip.text.x = element_text(size = 15, colour = "black", face='bold'),
strip.text.y = element_text(size = 15, colour = "black", face='bold'),
strip.background = element_rect(fill="orange"),
legend.position = "bottom",
legend.text=element_text(size=12, face = "bold"),
legend.title=element_text(size=14),
panel.border = element_rect(colour = "black", fill=NA, size=1))
# load the data:
setwd("~/Google Drive/Functional_Research/Earthquake_sensitivity")
# Read the data:
allINPUTS <- read.csv("./Data/Analysis2B/input_output_10272016/input_1500sim_10272016.csv")
# Rupture Module:
ruptureINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_rupture_1500sim_10272016.csv")
# Ground motion module:
groundMotionINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_GM_1500sim_10272016.csv")
# Damage module:
damageINPUT <- read.csv("./Data/Analysis2B/input_output_10272016/input_damage_1500sim_10272016.csv")
# Intermediate OUTPUTS:
damageOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_damage_1500sim_10272016.csv")
groundMotionOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_GM_1500sim_10272016.csv", header=FALSE)
library(Rcpp)
library(RcppArmadillo)
sourceCpp("./Scripts/klDivergenceCpp.cpp")
cppKLdiv <- function(.object, eps=10^-4,...){
if(!is.numeric(.object))
stop("object must be a numeric matrix\n")
w <- .object < eps
if (any(w)) .object[w] <- eps
.object <- sweep(.object, 2, colSums(.object) , "/")
.z <- KL_divergence(.object, rep(1,nrow(.object)))
colnames(.z) <- rownames(.z) <- colnames(.object)
.z
}
ggDAMAGE <- as.data.frame(t(damageOUTPUT))
ggDAMAGE$type <- factor(colnames(damageOUTPUT), levels = colnames(damageOUTPUT))
ggDAMAGE <- ggDAMAGE[-5,]
ggDAMAGE <- melt(ggDAMAGE, id="type")
ggplot(ggDAMAGE) + geom_line(aes(x=type, y=value, group=variable, colour = variable)) +
scale_colour_discrete(guide=FALSE) + universalTheme
ggplot(ggDAMAGE) + geom_boxplot(aes(x=type, y=value)) + universalTheme
damage.dist <- dist(damageOUTPUT[,-5]);
damage.mds  <- cmdscale(damage.dist, eig=TRUE, k=2)
damage.clustering = kmeans(damage.mds$points, 2, 50)$cluster
print(plotDGSAscatter(allINPUTS, damage.mds$points, .ggReturn = TRUE, .cb = TRUE) + universalTheme)
print(plotDGSAscatter(allINPUTS, damage.mds$points, .ggReturn = TRUE, .cb = TRUE) + universalTheme + theme(legend.position="right"))
print(plotDGSAscatter(allINPUTSfixed, damage.mds$points, .ggReturn = TRUE, .cb = TRUE) + universalTheme + theme(legend.position="right"))
MmedInputs        <- allINPUTS[,6:9]
MmedInputs.prcomp <- princomp(MmedInputs, cor=FALSE)
allINPUTSfixed <- allINPUTS
allINPUTSfixed[,6:9] <- MmedInputs.prcomp$scores
# We have to keep all of them!
colnames(allINPUTSfixed)[6:9] <- c("IM_pc1","IM_pc2","IM_pc3","IM_pc4")
print(plotDGSAscatter(allINPUTSfixed, damage.mds$points, .ggReturn = TRUE, .cb = TRUE) + universalTheme + theme(legend.position="right"))
damage.DGSA       <- DGSA::dgsa(damage.clustering, allINPUTS, .nBoot = 500, .interactions = TRUE)
plotMatrixDGSA(damage.DGSA, order = 'original', tl.cex = 1.4, hclust.method='centroid',
.hypothesis = FALSE, mar = marginsLeft <- c(2, 4, 1, 1) + 0.1)
gmX <- t(groundMotionOUTPUT[1,1:2001])
gmY <- t(groundMotionOUTPUT[,2002:4002])
curveNo <- t(matrix(rep(1:1500, 2001), byrow=FALSE, ncol=2001))
ggData.gm <- data.frame(X=as.vector(gmX), Y = as.vector(gmY), curve = as.vector(curveNo))
gm.dist <- dist(t(gmY));
gm.mds  <- cmdscale(gm.dist, eig=TRUE, k=3)
gm.clustering = kmeans(gm.mds$points, 2, 50)$cluster
print(plotDGSAscatter(allINPUTSfixed, gm.mds$points, .ggReturn = TRUE) + universalTheme)
print(plotDGSAscatter(allINPUTSfixed, gm.mds$points, .ggReturn = TRUE, .cb=TRUE) + universalTheme)
gm.DGSA <- DGSA::dgsa(gm.clustering, allINPUTS, .nBoot = 500, .interactions = TRUE)
plotMatrixDGSA(gm.DGSA, order = 'original', tl.cex = 1.4, hclust.method='centroid',
.hypothesis = FALSE, mar = marginsLeft <- c(2, 4, 1, 1) + 0.1)
lossOUTPUT   <- read.csv("./Data/Analysis2B/input_output_10272016/output_loss_1500sim_10272016.csv", header = FALSE)
injuryOUTPUT <- read.csv("./Data/Analysis2B/input_output_10272016/output_injuries_1500sim_10272016.csv")
lossScalar    <- data.frame(x=lossOUTPUT[,1])
lossX         <- t(lossOUTPUT[1,2:10002])
lossY         <- t(lossOUTPUT[,10003:20003])
lossY[is.nan(lossY)] <- 0
lossY[lossY<10e-04] = 10e-04
loss.KL.dist <- cppKLdiv(lossY)
loss.KL.dist <- as.matrix(loss.KL.dist)
loss.JS.dist <- 0.5*loss.KL.dist + 0.5*t(loss.KL.dist)
loss.JS.mds  <- cmdscale(loss.JS.dist, eig=TRUE, k=3)
# plot(cumsum(loss.JS.mds$eig[1:10]/sum(loss.JS.mds$eig[1:10])), type = "b", col="blue",
#      xlab = "Number of PCs", ylab = "fraction of variance explained")
# loss.JS.clustering = kmeans(loss.JS.mds$points, 2, 50)$cluster
# ------------------------------------------------------------------------------
# layout(matrix(1:2, 1, 2, byrow = TRUE),
#        widths=c(1,1), heights=c(1,1))
# marginsLeft <- c(4, 4, 1, 1) + 0.1
# par(mfrow=c(1,2))
# par(mar=marginsLeft)
# plot(cumsum(loss.JS.mds$eig[1:20]/sum(loss.JS.mds$eig[1:20])), type="b", col="blue", pch = 19,
#      xlab="Number of principal components", ylab="FVE",
#      col.lab="black", cex.lab=1.2, main = "Scree plot")
# box(lwd=2)
# par(mar=marginsLeft)
# plot(loss.JS.mds$points, xlab="Coordinate 1 (pc1)", ylab="Coordinate 2 (pc2)",
#      main="Metric MDS - loss", type="p", col.lab="black", cex.lab=1.2, pch=".")
# points(loss.JS.mds$points[loss.JS.clustering==1,], col="#E69F00", pch=8, cex=1.4)
# points(loss.JS.mds$points[loss.JS.clustering==2,], col="#56B4E9", pch=6)
# box(lwd=2)
# # ------------------------------------------------------------------------------
#
#
# print(plotDGSAscatter(allINPUTSfixed, loss.JS.mds$points, .ggReturn = TRUE) + universalTheme)
# print(plotCDFS(loss.JS.clustering, allINPUTSfixed, .code="all*", .ggReturn = TRUE) + universalTheme)
loss.JS.DGSA <- DGSA::dgsa(loss.JS.clustering, allINPUTS, .nBoot = 500, .interactions = TRUE)
plotMatrixDGSA(loss.JS.DGSA, order = 'original', tl.cex = 1.4, hclust.method='centroid',
.hypothesis = FALSE, mar = marginsLeft <- c(2, 4, 1, 1) + 0.1)
loss.JS.clustering = kmeans(loss.JS.mds$points, 2, 50)$cluster
loss.JS.DGSA <- DGSA::dgsa(loss.JS.clustering, allINPUTS, .nBoot = 500, .interactions = TRUE)
plotMatrixDGSA(loss.JS.DGSA, order = 'original', tl.cex = 1.4, hclust.method='centroid',
.hypothesis = FALSE, mar = marginsLeft <- c(2, 4, 1, 1) + 0.1)
print(plotDGSAscatter(allINPUTSfixed, loss.KL.mds$points, .ggReturn = TRUE, .cb=TRUE) + universalTheme)
print(plotDGSAscatter(allINPUTSfixed, loss.JS.mds$points, .ggReturn = TRUE, .cb=TRUE) + universalTheme)
ggINJURY <- as.data.frame(t(injuryOUTPUT))
ggINJURY$type <- factor(colnames(injuryOUTPUT), levels = colnames(injuryOUTPUT))
ggINJURY <- ggINJURY
ggINJURY <- melt(ggINJURY, id="type")
injury.dist <- dist(injuryOUTPUT);
injury.mds  <- cmdscale(injury.dist, eig=TRUE, k=3)
injury.clustering = kmeans(injury.mds$points, 2, 50)$cluster
print(plotDGSAscatter(allINPUTS, injury.mds$points, .ggReturn = TRUE) + universalTheme)
print(plotDGSAscatter(allINPUTS, injury.mds$points, .ggReturn = TRUE, .cb=TRUE) + universalTheme)
injury.DGSA <- DGSA::dgsa(injury.clustering, allINPUTS, .nBoot = 500, .interactions = TRUE)
plotMatrixDGSA(injury.DGSA, order = 'original', tl.cex = 1.4, hclust.method='centroid',
.hypothesis = FALSE, mar = marginsLeft <- c(2, 4, 1, 1) + 0.1)
sInd <- c(1:799, seq(800,10001,by=200))
ggLossData <- cbind.data.frame(x=lossX[sInd], lossY[sInd,])
ggLossData <- melt(ggLossData, id=c("x"))
ggplot(ggLossData) + geom_line(aes(x=x, y=value, group=variable), colour="#009E73") + scale_y_log10() + universalTheme
ggplot(ggLossData) + geom_line(aes(x=x, y=value, group=variable), colour="#009E73", alpha=0.7) + scale_y_log10() + universalTheme
ggplot(ggLossData) + geom_line(aes(x=x, y=value, group=variable), colour="#000000", alpha=0.7) + scale_y_log10() + universalTheme
ggplot(ggLossData) + geom_line(aes(x=x, y=value, group=variable), colour="#000000", alpha=0.7) +
scale_y_log10() + universalTheme + ylab("Y") + ggtitle("Loss Curves")
print(plotCDFS(damage.clustering, allINPUTS, .code="all*", .ggReturn = TRUE) + universalTheme)
colnames(allINPUTS)
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_MOD|IM_med_EXT", .ggReturn = TRUE) + universalTheme)
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_MOD", .ggReturn = TRUE) + universalTheme)
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_EXT", .ggReturn = TRUE) + universalTheme)
plot(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT, main=round(corr(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT),2))
plot(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT, main=round(cor(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT),2))
plot(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT, main=paste("correlation =", round(cor(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT),2)))
abline(0,1, col="red")
plot(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT, main=paste("correlation =", round(cor(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT),2)))
plot(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT,
main=paste("correlation =", round(cor(allINPUTS$IM_med_MOD, allINPUTS$IM_med_EXT),2)),
xlab="IM_med_MOD", ylab="IM_med_EXT")
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_MOD", .ggReturn = TRUE) + universalTheme)
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_EXT", .ggReturn = TRUE) + universalTheme)
print(plotCDFS(damage.clustering, allINPUTS, .code="IM_med_EXT|IM_med_EXT", .ggReturn = TRUE) + universalTheme)
plot(allINPUTS$IM_med_EXT, allINPUTS$IM_med_EXT,
main=paste("correlation =", round(cor(allINPUTS$IM_med_EXT, allINPUTS$IM_med_EXT),2)),
xlab="IM_med_MOD", ylab="IM_med_EXT")
plot(allINPUTS$IM_med_EXT, allINPUTS$IM_med_EXT,
main=paste("correlation =", round(cor(allINPUTS$IM_med_EXT, allINPUTS$IM_med_EXT),2)),
xlab="IM_med_EXT", ylab="IM_med_EXT")
edit(scaleInput)
devtools::document()
setwd("~/Google Drive/Functional_Research/DGSA")
devtools::document()
INPUT         <- read.csv("./data/Input.csv")
OUTPUT.damage <- read.csv("./data/Output_damage.csv")
comps  <- prcomp(OUTPUT.damage)
scores <- t(t(comps$x[,1:2])/comps$sdev[1:2])
clustering = kmeans(scores, 2, 50)$cluster
plot(scores)
points(scores[clustering == 1,], col="red", pch = 19)
points(scores[clustering == 2,], col="blue", pch=19)
# EDA for DGSA:
plotCDFS(clustering, INPUT, .code = "all*")
library(DGSA)
plotCDFS(clustering, INPUT, .code = "all*")
system.time(myDGSA <- dgsa(clustering, INPUT, .normalize = FALSE, .interactions = TRUE, .nBoot = 100))
plotMatrixDGSA(myDGSA)
plotMatrixDGSA(myDGSA, .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single')
system.time(myDGSA <- dgsa(clustering, INPUT, .normalize = TRUE, .interactions = TRUE, .nBoot = 100))
plotMatrixDGSA(myDGSA)
plotMatrixDGSA(myDGSA, .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single')
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', tl.srt = 65)
plotMatrixDGSA(myDGSA, order = 'hclust', hclust.method='single', .hypothesis = FALSE, tl.srt = 65)
plotMatrixDGSA(myDGSA, .method = "circle", .hypothesis = FALSE)
install.packages("~/Dropbox/JefOgy/R_dgsa/DGSA/", repos=NULL, type="source")
